let pressurePort, stepperPort, pressureReader;
let pressureData = [];
let buttonPressed = false;

document
  .getElementById("connectPressure")
  .addEventListener("click", async () => {
    pressurePort = await navigator.serial.requestPort();
    await pressurePort.open({ baudRate: 9600 });

    const textDecoder = new TextDecoderStream();
    const readableStreamClosed = pressurePort.readable.pipeTo(
      textDecoder.writable
    );
    const reader = textDecoder.readable.getReader();
    pressureReader = reader;
    readPressure();
  });

document
  .getElementById("connectStepper")
  .addEventListener("click", async () => {
    stepperPort = await navigator.serial.requestPort();
    await stepperPort.open({ baudRate: 9600 });
  });

async function readPressure() {
  while (true) {
    const { value, done } = await pressureReader.read();
    if (done) {
      break;
    }
    const [pressureReading, buttonState] = value.trim().split(",").map(Number);

    const pressureValue = isNaN(pressureReading) ? 0 : pressureReading;
    const button = isNaN(buttonState) ? 0 : buttonState;
    buttonPressed = false;
    if (button === 1) {
      buttonPressed = true;
    }

    if (!buttonPressed && pressureValue > 0) {
      pressureData.push(pressureValue);
    } else if (buttonPressed) {
      const stats = calculateStatistics(pressureData);

      generatePoem(stats);
    }

    if (pressureValue > 0) {
      moveStepperAndServo(pressureValue);
    }
  }
}

function calculateStatistics(data) {
  const mean = data.reduce((acc, val) => acc + val, 0) / data.length;

  const sortedData = [...data].sort((a, b) => a - b);
  const median =
    data.length % 2 === 0
      ? (sortedData[data.length / 2 - 1] + sortedData[data.length / 2]) / 2
      : sortedData[Math.floor(data.length / 2)];

  const mode = calculateMode(data);

  const variance =
    data.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / data.length;

  const standardDeviation = Math.sqrt(variance);

  return { mean, median, mode, variance, standardDeviation };
}

function calculateMode(data) {
  const frequency = {};
  data.forEach((value) => {
    frequency[value] = (frequency[value] || 0) + 1;
  });

  const maxFreq = Math.max(...Object.values(frequency));
  const modes = Object.keys(frequency).filter(
    (key) => frequency[key] === maxFreq
  );

  return modes.length === 1 ? Number(modes[0]) : modes;
}

function readPoetry(text) {
  if ("speechSynthesis" in window) {
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = "en-US";
    utterance.rate = 0.9;

    const voices = window.speechSynthesis.getVoices();

    utterance.voice =
      voices.find((voice) => voice.name === "Vicki") || voices[0];

    window.speechSynthesis.speak(utterance);
  } else {
    console.error("Speech Synthesis not supported in this browser.");
  }
}

async function generatePoem(stats) {
  const poemPrompt = `
    Write a single line of a poem inspired by the following statistical attributes:
    - Mean: ${stats.mean.toFixed(2)}
    - Median: ${stats.median.toFixed(2)}
    - Mode: ${stats.mode}
    - Variance: ${stats.variance.toFixed(2)}
    - Standard Deviation: ${stats.standardDeviation.toFixed(2)}

    I want the line to not reference the specific numbers or anything about statistical analysis. Do not explicity mention mean, median, mode, or standard deviation. Also, do not mention any particular kind of object in this poem either. Also do not include themes of the sublime. I want it to be generally inspired by the statistics to form a structure and inference the texture of the data. The poem should include themes of motion, feeling, sensation, craft, and artisanship in the abstract, similar to the sematic language structure generated by markov chains. Make the poem into a sound poem, with attention to tactile qualities in words. The poem should not ryhme. Feel free to make use of randomness. You do not need to make gramatical sense.
  `;

  const apiKey = "[Enter API Key Here]";
  const response = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer {apiKey}`, // Replace with your actual OpenAI API key
    },
    body: JSON.stringify({
      model: "gpt-4o",
      messages: [
        {
          role: "user",
          content: poemPrompt,
        },
      ],
      max_tokens: 100,
    }),
  });

  if (!response.ok) {
    console.error("API Error:", response.statusText);
    return "Error: Unable to generate poetry.";
  }

  const data = await response.json();
  console.log("API Response:", data);

  if (
    data.choices &&
    data.choices[0] &&
    data.choices[0].message &&
    data.choices[0].message.content
  ) {
    const poem = data.choices[0].message.content;
    displayPoem(poem);
  }
}

function displayPoem(poem) {
  readPoetry(poem);
  const poemDiv = document.getElementById("poem");
  poemDiv.innerHTML += `<p>${poem}</p>`;
}

async function moveStepperAndServo(pressureValue) {
  if (stepperPort) {
    const writer = stepperPort.writable.getWriter();

    const servoAngle = mapPressureToServo(pressureValue);

    const message = `MOVE ${pressureValue} ${servoAngle} \n`;
    console.log(message);

    await writer.write(new TextEncoder().encode(message));
    writer.releaseLock();
  }
}

function mapPressureToServo(pressureValue) {
  const clampedPressure = Math.min(pressureValue, 800);
  return mapValue(clampedPressure, 0, 800, 35, 60);
}

function mapValue(value, inMin, inMax, outMin, outMax) {
  return ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
}
